---
title: Cursores do conjunto de chaves (referência de banco de dados da área de trabalho do Access)
TOCTitle: Keyset cursors
ms:assetid: 4b6e5f90-4413-4fb3-0a08-2cb89d3c61f7
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249236(v=office.15)
ms:contentKeyID: 48544690
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 200b10599683a5b5877952664c04e94b2523cfee
ms.sourcegitcommit: d6695c94415fa47952ee7961a69660abc0904434
ms.translationtype: Auto
ms.contentlocale: pt-BR
ms.lasthandoff: 01/17/2019
ms.locfileid: "28721917"
---
# <a name="keyset-cursors"></a><span data-ttu-id="26273-102">Cursores de conjuntos de chaves</span><span class="sxs-lookup"><span data-stu-id="26273-102">Keyset cursors</span></span>

<span data-ttu-id="26273-103">**Aplica-se a**: Access 2013, o Office 2013</span><span class="sxs-lookup"><span data-stu-id="26273-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="26273-p101">O cursor controlado por conjunto de chaves fornece uma funcionalidade entre o cursor estático e o dinâmico com sua capacidade de detectar alterações. Assim como um cursor estático, esse cursor nem sempre detecta as alterações da associação e a ordem do conjunto de resultados. Como o cursor dinâmico, esse cursor detecta os valores das linhas no conjunto de resultados.</span><span class="sxs-lookup"><span data-stu-id="26273-p101">The keyset cursor provides functionality between a static and a dynamic cursor in its ability to detect changes. Like a static cursor, it does not always detect changes to the membership and order of the result set. Like a dynamic cursor, it does detect changes to the values of rows in the result set.</span></span>

<span data-ttu-id="26273-p102">Esse tipo de cursor é controlado por um conjunto exclusivo de identificadores (chaves), também conhecido como conjunto de chaves. As chaves são criadas a partir de um conjunto de colunas que identifica exclusivamente as linhas no conjunto de resultados. O conjunto de chaves é o conjunto de valores de chave de todas as linhas retornadas pela instrução de consulta.</span><span class="sxs-lookup"><span data-stu-id="26273-p102">Keyset-driven cursors are controlled by a set of unique identifiers (keys) known as the keyset. The keys are built from a set of columns that uniquely identify the rows in the result set. The keyset is the set of key values from all the rows returned by the query statement.</span></span>

<span data-ttu-id="26273-p103">Com esse tipo de cursor, é criada e salva uma chave em cada linha do cursor e armazenada na estação de trabalho do cliente ou no servidor. Quando você acessar cada linha, a chave armazenada será usada para buscar os valores de dados atuais da fonte de dados. Nesse tipo de cursor, a associação do conjunto de resultados será congelada quando o conjunto de chaves estiver totalmente preenchido. Por esse motivo, as adições ou as atualizações que afetam a associação não fazem parte do conjunto de resultados até que este seja reaberto.</span><span class="sxs-lookup"><span data-stu-id="26273-p103">With keyset-driven cursors, a key is built and saved for each row in the cursor and stored either on the client workstation or on the server. When you access each row, the stored key is used to fetch the current data values from the data source. In a keyset-driven cursor, result set membership is frozen when the keyset is fully populated. Thereafter, additions or updates that affect membership are not a part of the result set until it is reopened.</span></span>

<span data-ttu-id="26273-p104">As alterações dos valores de dados (feitas pelo proprietário do conjunto de chaves ou outros processos) são visíveis à medida que o usuário rolar o conjunto de resultados. As inserções feitas fora do cursor (por outros processos) serão visíveis somente se o cursor for fechado e reaberto. As inserções feitas no cursor são visíveis no final do conjunto de resultados.</span><span class="sxs-lookup"><span data-stu-id="26273-p104">Changes to data values (made either by the keyset owner or other processes) are visible as the user scrolls through the result set. Inserts made outside the cursor (by other processes) are visible only if the cursor is closed and reopened. Inserts made from inside the cursor are visible at the end of the result set.</span></span>

<span data-ttu-id="26273-p105">Quando um cursor controlado por conjunto de chaves tenta recuperar uma linha que tenha sido excluída, essa linha aparecerá como um "buraco" no conjunto de resultados. A chave da linha existe no conjunto de chaves, mas a linha não existe mais no conjunto de resultados. Se os valores de chave na linha são atualizados, a linha será considerada como se tivesse sido excluída e depois inserida; por esse motivo, tais linhas também aparecerem como buracos no conjunto de resultados. Ao mesmo tempo em que um cursor controlado por conjunto de chaves sempre pode detectar as linhas excluídas por outros processos, pode remover opcionalmente as chaves das linhas excluídas por ele mesmo. Os cursores que fazem isso não conseguem detectar suas próprias exclusões porque a evidência foi removida.</span><span class="sxs-lookup"><span data-stu-id="26273-p105">When a keyset-driven cursor attempts to retrieve a row that has been deleted, the row appears as a "hole" in the result set. The key for the row exists in the keyset, but the row no longer exists in the result set. If the key values in a row are updated, the row is considered to have been deleted and then inserted, so such rows also appear as holes in the result set. While a keyset-driven cursor can always detect rows deleted by other processes, it can optionally remove the keys for rows it deletes itself. Keyset-driven cursors that do this cannot detect their own deletes because the evidence has been removed.</span></span>

<span data-ttu-id="26273-p106">Uma atualização de uma coluna de chave opera como uma exclusão da chave antiga seguida da inserção de uma nova chave. O valor da nova chave não será visível se a atualização não foi feita pelo cursor. Em caso positivo, o valor da nova chave será visível no final do conjunto de resultados.</span><span class="sxs-lookup"><span data-stu-id="26273-p106">An update to a key column operates like a delete of the old key followed by an insert of the new key. The new key value is not visible if the update was not made through the cursor. If the update was made through the cursor, the new key value is visible at the end of the result set.</span></span>

<span data-ttu-id="26273-p107">Há uma variação nos cursores controlados por conjuntos de chaves denominada cursores padrão controlados por conjuntos de chaves. Nesse tipo de cursor, a associação das linhas ao conjunto de resultados e à ordem das linhas é fixada pelo tempo de abertura do cursor, mas as alterações dos valores feitas pelo proprietário do cursor e as alterações comprometidas feitas por outros processos são visíveis. Se uma alteração desqualificar uma linha da associação ou afetar a ordem de uma linha, a linha não desaparecerá ou será movida, a não ser que o cursor seja fechado e reaberto. Os dados inseridos não aparecerão, mas as alterações nos dados existentes aparecerão como as linhas buscadas.</span><span class="sxs-lookup"><span data-stu-id="26273-p107">There is a variation on keyset-driven cursors called keyset-driven standard cursors. In a keyset-driven standard cursor, the membership of rows in the result set and the order of the rows are fixed at cursor open time, but changes to values that are made by the cursor owner and committed changes made by other processes are visible. If a change disqualifies a row for membership or affects the order of a row, the row does not disappear or move unless the cursor is closed and reopened. Inserted data does not appear, but changes to existing data do appear as the rows are fetched.</span></span>

<span data-ttu-id="26273-p108">O cursor controlado por conjunto de chaves apresenta dificuldades para ser usado corretamente porque a sensibilidade às alterações de dados depende de muitas circunstâncias diferentes, como descrito anteriormente. No entanto, se o seu aplicativo não lida com atualizações simultâneas, pode tratar, de forma programática, das chaves incorretas e acessa diretamente certas linhas chaveadas, o cursor controlado por conjunto de chaves poderá funcionar no seu caso. Use **adOpenKeyset** **CursorTypeEnum** para indicar que você deseja usar o cursor controlado por conjunto de chaves no ADO.</span><span class="sxs-lookup"><span data-stu-id="26273-p108">The keyset-driven cursor is difficult to use correctly because the sensitivity to data changes depends on many differing circumstances, as described above. However, if your application is not concerned with concurrent updates, can programmatically handle bad keys, and must directly access certain keyed rows, the keyset-driven cursor might work for you. Use the **adOpenKeyset** **CursorTypeEnum** to indicate that you want to use a keyset cursor in ADO.</span></span>

