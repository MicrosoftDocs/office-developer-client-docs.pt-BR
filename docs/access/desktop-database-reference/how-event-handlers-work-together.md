---
title: Como os manipuladores de eventos trabalham juntos
TOCTitle: How event handlers work together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
ms.openlocfilehash: a397b0f88bb60552a6e53432a3c8c4d788013103
ms.sourcegitcommit: 1dd744993ecb4bed241ace874ad26edaef1778b8
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/06/2018
ms.locfileid: "25997265"
---
# <a name="how-event-handlers-work-together"></a><span data-ttu-id="ea0a0-102">Como os manipuladores de eventos trabalham juntos</span><span class="sxs-lookup"><span data-stu-id="ea0a0-102">How event handlers work together</span></span>

<span data-ttu-id="ea0a0-103">**Aplica-se a**: Access 2013, o Office 2013</span><span class="sxs-lookup"><span data-stu-id="ea0a0-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="ea0a0-p101">A menos que esteja fazendo uma programação em Visual Basic, todos os manipuladores de eventos **Connection** e **Recordset** deverão ser implementados, independentemente do processamento ou não de todos os eventos. O volume de implementação a ser executado dependerá da linguagem de programação. Para obter mais informações, consulte [Instanciação de eventos ADO por linguagem](https://msdn.microsoft.com/library/jj250244\(v=office.15\)).</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p101">Unless you are programming in Visual Basic, all event handlers for **Connection** and **Recordset** events must be implemented, regardless of whether you actually process all of the events. The amount of implementation work you have to do depends on your programming language. For more information, see [ADO Event Instantiation by Language](https://msdn.microsoft.com/library/jj250244\(v=office.15\)).</span></span>

## <a name="paired-event-handlers"></a><span data-ttu-id="ea0a0-107">Manipuladores de eventos emparelhados</span><span class="sxs-lookup"><span data-stu-id="ea0a0-107">Paired event handlers</span></span>

<span data-ttu-id="ea0a0-p102">Cada manipulador de eventos Will possui um manipulador de eventos Complete associado. Por exemplo, quando seu aplicativo altera o valor de um campo, o manipulador de eventos **WillChangeField** é chamado. Se a alteração for aceitável, o aplicativo não alterará o parâmetro **adStatus** e a operação será executada. Quando ela for concluída, um evento **FieldChangeComplete** notificará o aplicativo de que a operação foi finalizada. Se a operação for concluída com êxito, **adStatus** conterá **adStatusOK**; caso contrário, ele conterá **adStatusErrorsOccurred** e você deverá verificar o objeto **Error** para determinar a causa do erro\*\*\*\*.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p102">Each Will event handler has an associated Complete event handler. For example, when your application changes the value of a field, the **WillChangeField** event handler is called. If the change is acceptable, your application leaves the **adStatus** parameter unchanged and the operation is performed. When the operation completes, a **FieldChangeComplete** event notifies your application that the operation has finished. If it completed successfully, **adStatus** contains **adStatusOK**; otherwise, **adStatus** contains **adStatusErrorsOccurred** and you must check the **Error** object to determine the cause of the error.</span></span>

<span data-ttu-id="ea0a0-p103">Quando **WillChangeField** for chamado, você poderá determinar a não execução da alteração. Nesse caso, defina **adStatus** como **adStatusCancel**. A operação será cancelada e o evento **FieldChangeComplete** receberá o valor **adStatusErrorsOccurred** para **adStatus**. O objeto **Error** contém **adErrOperationCancelled**, para que o manipulador **FieldChangeComplete** saiba sobre o cancelamento da operação. Entretanto, você precisará verificar o valor do parâmetro **adStatus** antes de alterá-lo já que a configuração de **adStatus** como **adStatusCancel** não terá efeito se o parâmetro tiver sido definido como **adStatusCantDeny** na entrada para o procedimento.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p103">When **WillChangeField** is called, you might determine that the change should not be made. In that case, set **adStatus** to **adStatusCancel**. The operation is canceled and the **FieldChangeComplete** event receives an **adStatus** value of **adStatusErrorsOccurred**. The **Error** object contains **adErrOperationCancelled** so that your **FieldChangeComplete** handler knows that the operation was canceled. However, you need to check the value of the **adStatus** parameter before changing it, because setting **adStatus** to **adStatusCancel** has no effect if the parameter was set to **adStatusCantDeny** on entry to the procedure.</span></span>

<span data-ttu-id="ea0a0-p104">Algumas vezes, uma operação pode gerar mais de um evento. Por exemplo, o objeto **Recordset** possui eventos associados para alterações de **Field** e para alterações de **Record**. Quando seu aplicativo alterar o valor de um **Field**, o manipulador de eventos **WillChangeField** será chamado. Se ele determinar que é possível continuar a operação, o manipulador de eventos **WillChangeRecord** também será gerado. Se esse manipulador também permitir a continuação do evento, a alteração será efetuada e os manipuladores de eventos **FieldChangeComplete** e **RecordChangeComplete** serão chamados. A ordem de chamada dos manipuladores de eventos Will para uma operação específica é indefinida, portanto, evite criar um código que dependa da chamada de manipuladores em uma sequência específica.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p104">Sometimes an operation can raise more than one event. For example, the **Recordset** object has paired events for **Field** changes and **Record** changes. When your application changes the value of a **Field**, the **WillChangeField** event handler is called. If it determines that the operation can continue, the **WillChangeRecord** event handler is also raised. If this handler also allows the event to continue, the change is made and the **FieldChangeComplete** and **RecordChangeComplete** event handlers are called. The order in which the Will event handlers for a particular operation are called is not defined, so you should avoid writing code that depends on calling handlers in a particular sequence.</span></span>

<span data-ttu-id="ea0a0-p105">Em instâncias com vários eventos Will gerados, um dos eventos poderá cancelar a operação pendente. Por exemplo, quando seu aplicativo altera o valor de um **Field**, normalmente os manipuladores de eventos **WillChangeField** e **WillChangeRecord** são chamados. Entretanto, se a operação for cancelada no primeiro manipulador de eventos, seu manipulador Complete associado será imediatamente chamado através de **adStatusOperationCancelled**. O segundo manipulador nunca é chamado. No entanto, se o primeiro manipulador de eventos permitir a continuação do evento, o outro será chamado. Se, em seguida, ele cancelar a operação, os dois eventos Complete serão chamados como nos exemplos anteriores.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p105">In instances when multiple Will events are raised, one of the events might cancel the pending operation. For example, when your application changes the value of a **Field**, both **WillChangeField** and **WillChangeRecord** event handlers would normally be called. However, if the operation is canceled in the first event handler, its associated Complete handler is immediately called with **adStatusOperationCancelled**. The second handler is never called. If, however, the first event handler allows the event to proceed, the other event handler will be called. If it then cancels the operation, both Complete events will be called as in the earlier examples.</span></span>

## <a name="unpaired-event-handlers"></a><span data-ttu-id="ea0a0-130">Manipuladores de eventos não emparelhados</span><span class="sxs-lookup"><span data-stu-id="ea0a0-130">Unpaired event handlers</span></span>

<span data-ttu-id="ea0a0-131">Desde que o status passado ao evento não for **adStatusCantDeny**, você pode desativar as notificações de evento para qualquer evento, retornando **adStatusUnwantedEvent** no parâmetro *Status* .</span><span class="sxs-lookup"><span data-stu-id="ea0a0-131">As long as the status passed to the event is not **adStatusCantDeny**, you can turn off event notifications for any event by returning **adStatusUnwantedEvent** in the *Status* parameter.</span></span> <span data-ttu-id="ea0a0-132">Por exemplo, quando o manipulador de eventos Complete for chamado pela primeira vez, você poderá retornar **adStatusUnwantedEvent**.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-132">For example, when your Complete event handler is called the first time, you can return **adStatusUnwantedEvent**.</span></span> <span data-ttu-id="ea0a0-133">Em seguida, você receberá apenas eventos Will.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-133">You will subsequently receive only Will events.</span></span> <span data-ttu-id="ea0a0-134">Entretanto, alguns eventos podem ser disparados por mais de um motivo.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-134">However, some events can be triggered for more than one reason.</span></span> <span data-ttu-id="ea0a0-135">Nesse caso, o evento terá um parâmetro *motivo* .</span><span class="sxs-lookup"><span data-stu-id="ea0a0-135">In that case, the event will have a *Reason* parameter.</span></span> <span data-ttu-id="ea0a0-136">Ao retornar **adStatusUnwantedEvent**, você não receberá mais notificações desse evento, somente quando elas ocorrerem por um motivo específico.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-136">When you return **adStatusUnwantedEvent**, you will stop receiving notifications for that event only when they occur for that particular reason.</span></span> <span data-ttu-id="ea0a0-137">Isso significa que você provavelmente receberá uma notificação de cada possível motivo para o disparo do evento.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-137">In other words, you will potentially receive notification for each possible reason that the event could be triggered.</span></span>

<span data-ttu-id="ea0a0-p107">Um único manipulador de eventos Will pode ser útil quando você deseja examinar os parâmetros a serem usados em uma operação. Você pode modificar esses parâmetros de operação ou cancelar a operação.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p107">Single Will event handlers can be useful when you want to examine the parameters that will be used in an operation. You can modify those operation parameters or cancel the operation.</span></span>

<span data-ttu-id="ea0a0-p108">Você também pode manter a notificação do evento Complete habilitada. Quando o primeiro manipulador de eventos Will for chamado, retorne **adStatusUnwantedEvent**. Em seguida, você receberá apenas eventos Complete.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p108">Alternatively, leave Complete event notification enabled. When your first Will event handler is called, return **adStatusUnwantedEvent**. You will subsequently receive only Complete events.</span></span>

<span data-ttu-id="ea0a0-p109">Um único manipulador de eventos Complete pode ser útil para o gerenciamento de operações assíncronas. Cada operação assíncrona possui um evento Complete apropriado.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p109">Single Complete event handlers can be useful for managing asynchronous operations. Each asynchronous operation has an appropriate Complete event.</span></span>

<span data-ttu-id="ea0a0-145">Por exemplo, o preenchimento de um grande objeto [Recordset](recordset-object-ado.md) pode ser demorado.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-145">For example, it can take a long time to populate a large [Recordset](recordset-object-ado.md) object.</span></span> <span data-ttu-id="ea0a0-146">Se seu aplicativo está escrito corretamente, você pode iniciar uma operação e continuar com outro processamento.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-146">If your application is appropriately written, you can start a operation and continue with other processing.</span></span> <span data-ttu-id="ea0a0-147">No final, você será notificado quando **Recordset** for preenchido por um evento **ExecuteComplete**.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span></span>

## <a name="single-event-handlers-and-multiple-objects"></a><span data-ttu-id="ea0a0-148">Manipuladores de evento único e vários objetos</span><span class="sxs-lookup"><span data-stu-id="ea0a0-148">Single event handlers and multiple objects</span></span>

<span data-ttu-id="ea0a0-p111">A flexibilidade de uma linguagem de programação como o Microsoft Visual C++ permite ter eventos de processo de um único manipulador de eventos a partir de vários objetos. Por exemplo, você pode ter eventos de processo de um único manipulador de eventos **Disconnect** a partir de vários objetos **Connection**. Se uma das conexões for encerrada, o manipulador de eventos **Disconnect** será chamado. É possível saber qual conexão causou o evento, pois o parâmetro de objeto manipulador de eventos é definido para o objeto **Connection** correspondente.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-p111">The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects. For example, you could have one **Disconnect** event handler process events from several **Connection** objects. If one of the connections ended, the **Disconnect** event handler would be called. You could tell which connection caused the event because the event-handler object parameter would be set to the corresponding **Connection** object.</span></span>

> [!NOTE]
> <span data-ttu-id="ea0a0-153">[!OBSERVAçãO] Essa técnica não pode ser usada no Visual Basic, pois essa linguagem apenas pode correlacionar um objeto a um manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="ea0a0-153">This technique cannot be used in Visual Basic because that language can correlate only one object to an event handler.</span></span>


