---
title: Interagir com o spooler MAPI
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 5cc1d0a8-ad23-4173-b220-b7c0169073fa
description: 'Última modificação: 23 de julho de 2011'
ms.openlocfilehash: da94347dcb47e5fdbd4a6c1d404b795f4f7938ab
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/23/2019
ms.locfileid: "32317203"
---
# <a name="interacting-with-the-mapi-spooler"></a><span data-ttu-id="ec0c0-103">Interagir com o spooler MAPI</span><span class="sxs-lookup"><span data-stu-id="ec0c0-103">Interacting with the MAPI Spooler</span></span>

  
  
<span data-ttu-id="ec0c0-104">**Aplica-se a**: Outlook 2013 | Outlook 2016</span><span class="sxs-lookup"><span data-stu-id="ec0c0-104">**Applies to**: Outlook 2013 | Outlook 2016</span></span> 
  
<span data-ttu-id="ec0c0-105">Os métodos na interface [IXPLogon: IUnknown](ixplogoniunknown.md) são usados pelo spooler MAPI ao chamar o provedor de transporte.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-105">The methods in the [IXPLogon : IUnknown](ixplogoniunknown.md) interface are used by the MAPI spooler when calling the transport provider.</span></span> <span data-ttu-id="ec0c0-106">Deve ser possível para a maioria dos tipos de provedores de transporte implementar a maioria desses métodos para que eles retornem rapidamente.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-106">It should be possible for most types of transport providers to implement most of these methods so that they return quickly.</span></span> <span data-ttu-id="ec0c0-107">Isso é desejável porque se um método levar muito tempo para retornar, deve ser dividido com chamadas de volta para o spooler MAPI para liberar a CPU para outras tarefas.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-107">This is desirable because if a method takes a long time to return then it should be broken up with calls back to the MAPI spooler to release the CPU for other tasks.</span></span> 
  
<span data-ttu-id="ec0c0-108">O MAPI spooler funciona e faz suas chamadas para provedores de transporte quando os aplicativos de primeiro plano estiverem ociosos.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-108">The MAPI spooler does its work and makes its calls to transport providers when foreground applications are idle.</span></span> <span data-ttu-id="ec0c0-109">Após exibir opcionalmente caixas de diálogo quando o provedor de transporte é conectado pela primeira vez (regido pelos sinalizadores passados de MAPI para o provedor de transporte), os provedores de transporte operam em segundo plano, a menos que o cliente tenha sido chamado pelo cliente para liberar as filas de envio e recebimento.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-109">After optionally displaying dialog boxes when the transport provider is first logged on (governed by flags passed from MAPI to the transport provider), transport providers operate in the background unless called by the client to flush send and receive queues.</span></span> <span data-ttu-id="ec0c0-110">A liberação de filas é a única vez que um provedor de transporte não precisa liberar a CPU e, em seguida, somente se o usuário for informado de que uma ação possivelmente longa está em andamento.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-110">Flushing queues is the only time that a transport provider need not release the CPU, and then only if the user is informed that a potentially long action is in progress.</span></span> <span data-ttu-id="ec0c0-111">O spooler MAPI normalmente solicita que um provedor de transporte libere suas filas em resposta a uma ação do usuário, portanto, o provedor de transporte normalmente não precisa fazer nada para garantir que o usuário seja informado.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-111">The MAPI spooler typically requests that a transport provider flush its queues in response to a user action, so the transport provider typically does not need to do anything to ensure that the user is informed.</span></span>
  
<span data-ttu-id="ec0c0-112">Um provedor de transporte pode decidir de forma independente a liberação de uma fila e usar os bits STATUS_INBOUND_FLUSH e STATUS_OUTBOUND_FLUSH na propriedade **PR_STATUS_CODE** ([PidTagStatusCode](pidtagstatuscode-canonical-property.md)) de sua linha de status para informar ao spooler MAPI que ele deseja atenção para que possa realizar o trabalho.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-112">A transport provider can independently decide to flush a queue and use the STATUS_INBOUND_FLUSH and STATUS_OUTBOUND_FLUSH bits in the **PR_STATUS_CODE** ([PidTagStatusCode](pidtagstatuscode-canonical-property.md)) property of its status row to inform the MAPI spooler that it wants attention so that it can get the job done.</span></span> <span data-ttu-id="ec0c0-113">A linha de status é atualizada usando o método [IMAPISupport:: ModifyStatusRow](imapisupport-modifystatusrow.md) .</span><span class="sxs-lookup"><span data-stu-id="ec0c0-113">The status row is updated using the [IMAPISupport::ModifyStatusRow](imapisupport-modifystatusrow.md) method.</span></span> <span data-ttu-id="ec0c0-114">Nesse caso, o provedor de transporte deve provavelmente exibir um indicador de progresso ou outra interface para informar ao usuário que uma ação longa está ocorrendo.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-114">In this case the transport provider should probably display a progress indicator or other interface to inform the user that a long action is occuring.</span></span> 
  
<span data-ttu-id="ec0c0-115">Como a atividade de rede geralmente leva mais de 0,2 segundos, os provedores de transporte devem, sempre que possível, usar solicitações de rede assíncronas.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-115">Since network activity often takes more than 0.2 seconds, transport providers should, whenever possible, use asynchronous network requests.</span></span> <span data-ttu-id="ec0c0-116">Isso permite que eles iniciem uma solicitação, liberem a CPU ligando de volta ao spooler MAPI e, quando o spooler MAPI der novamente controle, verifique se a solicitação de rede foi concluída.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-116">This enables them to initiate a request, release the CPU by calling back to the MAPI spooler, and when the MAPI spooler again gives them control, to check to see if their network request has completed.</span></span> <span data-ttu-id="ec0c0-117">Se ele ainda não tiver sido concluído, libere novamente a CPU ligando de volta ao spooler MAPI com o método [IMAPISupport:: SpoolerYield](imapisupport-spooleryield.md) .</span><span class="sxs-lookup"><span data-stu-id="ec0c0-117">If it has not yet completed, they again release the CPU by calling back to the MAPI spooler with the [IMAPISupport::SpoolerYield](imapisupport-spooleryield.md) method.</span></span> 
  
<span data-ttu-id="ec0c0-118">Durante o processamento de mensagens, entre [IXPLogon:: SubmitMessage](ixplogon-submitmessage.md) e [IXPLogon:: endmessage](ixplogon-endmessage.md) e durante [IXPLogon:: StartMessage](ixplogon-startmessage.md), o provedor de transporte geralmente faz muitas chamadas em objetos expostos a ele pelo spooler MAPI.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-118">During message processing, between [IXPLogon::SubmitMessage](ixplogon-submitmessage.md) and [IXPLogon::EndMessage](ixplogon-endmessage.md) and during [IXPLogon::StartMessage](ixplogon-startmessage.md), the transport provider typically makes many calls on objects exposed to it by the MAPI spooler.</span></span> <span data-ttu-id="ec0c0-119">Como parte de sua manipulação desses objetos, o spooler MAPI ajuda o provedor de transporte a se comportar apropriadamente como um processo de plano de fundo por meio de seu próprio, quando apropriado.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-119">As part of its handling of these objects, the MAPI spooler helps the transport provider behave appropriately as a background process by yielding on its own when appropriate.</span></span> <span data-ttu-id="ec0c0-120">Um provedor de transporte que requer o processamento de tempo crítico pode declarar uma seção crítica para o spooler MAPI usando o método de objeto de suporte [IMAPISupport:: SpoolerNotify](imapisupport-spoolernotify.md) .</span><span class="sxs-lookup"><span data-stu-id="ec0c0-120">A transport provider requiring time-critical processing can declare a critical section to the MAPI spooler using the [IMAPISupport::SpoolerNotify](imapisupport-spoolernotify.md) support object method.</span></span> <span data-ttu-id="ec0c0-121">Nesse caso, a CPU é liberada somente em chamadas **SpoolerYield** explícitas pelo provedor de transporte até que o provedor de transporte termine o processamento de seção crítico com outra chamada para **SpoolerNotify**.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-121">In this case, the CPU is released only on explicit **SpoolerYield** calls by the transport provider until the transport provider ends critical section processing with another call to **SpoolerNotify**.</span></span>
  
> [!NOTE]
> <span data-ttu-id="ec0c0-122">Isso não é o mesmo que uma seção crítica do Win32.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-122">This is not the same as a Win32 critical section.</span></span> <span data-ttu-id="ec0c0-123">Isso deve ser feito apenas quando o provedor de transporte precisa de controle em tempo real de recursos externos, como a leitura de dados de entrada de uma linha de fax.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-123">This should only be done when the transport provider needs real-time control of external resources such as reading incoming data from a fax line.</span></span> <span data-ttu-id="ec0c0-124">Como isso gera a prioridade do processo de spooler MAPI e pode fazer com que a estação de trabalho pare de responder pela duração da operação, é uma boa ideia notificar o usuário de que uma ação possivelmente longa está em andamento e fornecer um indicador de progresso, se possível.</span><span class="sxs-lookup"><span data-stu-id="ec0c0-124">Since this raises the priority of the MAPI spooler process and can cause the workstation to be unresponsive for the duration of the operation, it is a good idea to notify the user that a potentially long action is underway and provide a progress indicator if possible.</span></span> 
  

